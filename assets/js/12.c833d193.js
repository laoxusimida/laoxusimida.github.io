(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{486:function(n,t,a){"use strict";a.r(t);var e=a(58),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h3",{attrs:{id:"loadsh-笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loadsh-笔记"}},[n._v("#")]),n._v(" loadsh 笔记")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("// 分割数组---按照要求分割\nconst arry = [1,2,3,4,5]\nconsole.log(_.chunk(arry, 2))\n\n// 筛选数组--筛选非假值\nconsole.log(_.compact([1, '', 6, false, 8]))\n\n\n// 拼接数组  使用_.contact也可以   \nconsole.log([1,2,3].concat(5))\n// 将值添加到数组中方法\n// 1、 push unshift contact _.contact \n\nconsole.log( _.fromPairs([[\"nihao\", 123],[\"hello\", 45]]))\n\n// _.pullAt移除数组中的元素返回值时被移除元素组成的数组，原数组发生改变为移除后的数组\n// 原生js可以用splice(index,1)  从哪开始移除移除多少个\nconst arr1 = [1,2,3,4,5]\nconst even = _.pullAt(arr1, 1, 3)\nconsole.log(arr1)\nconsole.log(even)\n\n// 生成0-9元素数组\nconsole.log(_.range(10))\n// 循环十次\n// 可自动执行代码n次\n// _.times(20, item=> {console.log(item)})\n// 自动生成id ---给元素起id时可以使用\nconst obj ={\n  'username':'nihao'\n}\nconsole.log(_.uniqueId(obj.username))\n\nvar arr2 = [4,5,6,4]\nvar arr3 = [7,4,9]\n// union数组去重合并数组后去除重复的\nconsole.log(_.union(arr2,arr3))\n// 数组去重\nconsole.log(_.uniq(arr2))\n\n// filter和reject\n// filter返回的是被过滤的值形成的数组\nconst arr4 = _.filter(arr2, item=>{\n  return item === 5\n})\nconsole.log(arr4)\n// reject返回的是过滤后的值形成的数组\nconst arr5 = _.reject(arr2, item=>{\n  return item === 5\n})\nconsole.log(arr5)\n\n// merge参数对象合并\nvar obj1 ={\n  \"a\": 'jj'\n}\nvar obj2 = {\n  \"b\": 'hh'\n}\nconst obj3 = _.merge(obj1, obj2)\nconsole.log(obj3)\n\n// _.key和object.key类似可以获取对象中的键组成数组\n")])])]),a("h3",{attrs:{id:"防抖节流知识-debounce-和-throttle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防抖节流知识-debounce-和-throttle"}},[n._v("#")]),n._v(" 防抖节流知识 _.debounce 和 _.throttle")]),n._v(" "),a("p",[a("img",{attrs:{src:"/img/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81.png",alt:"防抖节流"}})]),n._v(" "),a("h3",{attrs:{id:"对es6类的属性和方法的认识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对es6类的属性和方法的认识"}},[n._v("#")]),n._v(" 对es6类的属性和方法的认识")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v(" // 1. 构造函数的问题. \n    function Star(uname, age) {\n        this.uname = uname;\n        this.age = age;\n        // this.sing = function() {\n        //     console.log('我会唱歌');\n\n        // }\n    }\n    Star.prototype.sing = function () {\n        console.log('我会唱歌');\n    }\n\n\n    var ldh = new Star('刘德华', 18);\n    var zxy = new Star('张学友', 19);\n    console.log(ldh.sing === zxy.sing);\n    // console.dir(Star);\n    ldh.sing();\n    zxy.sing();\n    // 2. 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上\n")])])]),a("h3",{attrs:{id:"原型对象的应用-扩展内置对象方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型对象的应用-扩展内置对象方法"}},[n._v("#")]),n._v(" 原型对象的应用 扩展内置对象方法")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    Array.prototype.sum = function() {\n        var sum = 0;\n        for (var i = 0; i < this.length; i++) {\n            sum += this[i];\n        }\n        return sum;\n    };\n    // Array.prototype = {\n    //     sum: function() {\n    //         var sum = 0;\n    //         for (var i = 0; i < this.length; i++) {\n    //             sum += this[i];\n    //         }\n    //         return sum;\n    //     }\n\n    // }\n    var arr = [1, 2, 3];\n    console.log(arr.sum());\n    console.log(Array.prototype);\n    var arr1 = new Array(11, 22, 33);\n    console.log(arr1.sum());\n")])])]),a("h3",{attrs:{id:"子构造函数继承父构造函数方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#子构造函数继承父构造函数方法"}},[n._v("#")]),n._v(" 子构造函数继承父构造函数方法")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    // 借用父构造函数继承属性\n    // 1 父构造函数\n    function Father(uname, age) {\n        this.uname = uname;\n        this.age = age\n    }\n    // 子构造函数  必须将父构造函数的this也继承过来才可以使用父构造函数内的属性以及方法\n    function Son(uname, age, score) {\n        Father.call(this,uname, age)\n        this.score = score\n    }\n    var son = new Son('小徐', 18, 98)\n    console.log(son);\n")])])]),a("h3",{attrs:{id:"对object-definepropety的认识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对object-definepropety的认识"}},[n._v("#")]),n._v(" 对Object.definePropety的认识")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("    // 2. Object.defineProperty() 定义新属性或修改原有的属性\n    Object.defineProperty(obj, 'num', {\n        value: 1000,\n        enumerable: true\n    });\n    console.log(obj);\n    Object.defineProperty(obj, 'price', {\n        value: 9.9\n    });\n    console.log(obj);\n    Object.defineProperty(obj, 'id', {\n        // 如果值为false 不允许修改这个属性值 默认值也是false\n        writable: false,\n    });\n    obj.id = 2;\n    console.log(obj);\n    Object.defineProperty(obj, 'address', {\n        value: '中国山东蓝翔技校xx单元',\n        // 如果只为false 不允许修改这个属性值 默认值也是false\n        writable: false,\n        // enumerable 如果值为false 则不允许遍历, 默认的值是 false\n        enumerable: false,\n        // configurable 如果为false 则不允许删除这个属性 不允许在修改第三个参数里面的特性 默认为false\n        configurable: false\n    });\n")])])]),a("h3",{attrs:{id:"函数的调用形式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数的调用形式"}},[n._v("#")]),n._v(" 函数的调用形式")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("1、普通函数调用   this指向全局方法window对象 在严格模式下指向undefined\n2、构造函数调用 new function   this指向实例对象\n3、事件处理程序 this指向函数触发者\n4、定时器  在时间到时触发函数  this指向window\n5、立即执行函数 this指向window\n6、对象的方法  对象.方法() this指向对象\n")])])]),a("h3",{attrs:{id:"改变this的指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#改变this的指向"}},[n._v("#")]),n._v(" 改变this的指向")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("1、applay()  参数以数组的形式\n2、 call()\n3、 bind()  不会执行函数仅仅改变this的指向\n")])])]),a("h3",{attrs:{id:"深拷贝和浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝"}},[n._v("#")]),n._v(" 深拷贝和浅拷贝")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("堆和栈\n简单数据类型将数据放在栈中\n引用数据类型将数据放在堆当中\n当简单数据类型拷贝时只需要将栈中的数据复制一份赋值\n引用数据类型浅拷贝只需要将栈中的地址赋值\n当被赋值的变量改变时将会改变数据\n")])])]),a("h3",{attrs:{id:"深拷贝和浅拷贝的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝的方法"}},[n._v("#")]),n._v(" 深拷贝和浅拷贝的方法")]),n._v(" "),a("p",[a("img",{attrs:{src:"/img/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D.png",alt:"深拷贝和浅拷贝"}})]),n._v(" "),a("h3",{attrs:{id:"同步与异步任务的认识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步与异步任务的认识"}},[n._v("#")]),n._v(" 同步与异步任务的认识")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("js的异步与同步任务\n由于js与java不同，js是单线程的，js是脚本语言，在执行的时候如果为多线程\n的则会产生效果的混乱，比如执行添加和删除操作\njs代码有同步异步操作过程简单来说\n图形介绍\n")])])]),a("p",[a("img",{attrs:{src:"/img/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1.png",alt:"同步任务与异步任务"}})]),n._v(" "),a("h3",{attrs:{id:"http与https的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http与https的区别"}},[n._v("#")]),n._v(" http与https的区别")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("http与https区别\nhttp为明文传输会被抓包窃取\nhttps=http+ssl/tsl 安全套接层用来传输数据加密\n对称数加密：客户端和服务器通过同一把钥匙进行加密解密---钥匙被黑客获取不安全\n非对称加密：客户端进行公钥加密，服务端通过私钥进行解密\n客户端接收服务端返回的公钥可能被中间人拦截，返回一个虚假的公钥会将客户端传递的数据暴露\n此时需要证书签名和公钥共同使用，在返回公钥时对证书签名进行验证才知道公钥是不是正确的\n\n真正的https传输是通过非对称式加密进行建立安全关系，服务端有公钥和私钥以及秘钥，之后的通信\n通过秘钥进行对称式加密进行的\n")])])]),a("h4",{attrs:{id:"tcp传输控制协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp传输控制协议"}},[n._v("#")]),n._v(" TCP传输控制协议")]),n._v(" "),a("h5",{attrs:{id:"三次握手与四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手与四次挥手"}},[n._v("#")]),n._v(" 三次握手与四次挥手")]),n._v(" "),a("p",[a("img",{attrs:{src:"/img/tcp_request.png",alt:"TCP传输三次握手"}}),n._v(" "),a("img",{attrs:{src:"/img/sici.png",alt:"TCP传输四次挥手"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);